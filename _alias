#!/bin/bash

# "do" : execute one command on multiple folders
alias d='~/bin/d'

uname="$(uname)"
if [ 'MINGW' = "${uname:0:5}" ]; then
    IS_WINDOWS=1
else
    IS_WINDOWS=0
fi

if [[ 1 -eq $IS_WINDOWS ]]; then
    alias dir='ls'
fi

which xmlstarlet > /dev/null
if [[ 0 -eq $? ]]; then
    alias x='xmlstarlet'
fi

which xdg-open > /dev/null
if [[ 0 -eq $? ]]; then
    alias o='xdg-open'
    # TODO : make it work when only gnome-open is available
fi

# Ack
which ack > /dev/null
if [[ 0 -eq $? ]]; then
    alias a='ack'
fi

# Maven
which mvn > /dev/null
if [[ 0 -eq $? ]]; then
    alias mcist='mvn clean install -DskipTests'
    alias mci='mvn clean install'
    alias m='mvn'
    alias md='mvnDebug'

    # default effective pom output
    mvn_effective_pom_file='target/effective-pom.xml'

    # maven effective pom
    mvn_effective_pom () {
       local out="${1:-$mvn_effective_pom_file}"
       mvn help:effective-pom -Doutput="$out" >/dev/null || return 1
    }

    mdep (){
       local outFile='target/.mdep'
       mvn dependency:tree -DoutputFile="$outFile" "$@">/dev/null || return 1
       cat "$outFile"
       rm -f "$outFile"
    }

    # WIP tools
    # TODO : add feature detection of xmlstarlet

    # maven project version (with submodules)
    mpv () {
       mvn_effective_pom || return 1

       # remove namespace declarations for easy selection (xmlstarlet is a pain here)
       sed -i 's/<project .*>/<project>/' "${mvn_effective_pom_file}"

       xmlstarlet sel -t -m '//project' \
          -v 'groupId'  -o ' '  -v 'artifactId'  -o ' '  -v 'version' -n \
          "${mvn_effective_pom_file}"
       rm -f "${mvn_effective_pom_file}"
    }

    # maven effective pom (output to console for easy grep)
    mep () {
       local out="${1:-$mvn_effective_pom_file}"
       mvn_effective_pom $out && cat $out && rm -f $out
    }


fi

# Git
which git > /dev/null
if [[ 0 -eq $? ]]; then
    # taken as-is form zsh/oh-my-zsh configuration to make it work with bash too
    _current_branch () {
      ref=$(git symbolic-ref HEAD 2>/dev/null) || head=$(git rev-parse --short HEAD 2>/dev/null)
      echo ${ref#refs/heads/}
    }

    alias g='git'
    alias gl='git log --decorate --oneline --graph'
    alias gld='git log --decorate --oneline --graph --simplify-by-decoration'
    alias gls='git ls-files --exclude-standard'
    alias gh='git help'
    alias gpr='git pull --rebase'
    alias gp='git pull'
    alias gpu='git push'
    alias gf='git fetch --all --tags'
    alias gst='git status -sb'
    alias ga='git add'
    alias gap='git add -vp'
    alias gr='git reset'
    alias gds='git diff --staged'
    alias gd='git diff'
    alias gc='git commit'
    alias ggpull='git pull --rebase origin $(_current_branch) && git fetch --all'
    alias ggpush='git push origin $(_current_branch)'
    alias gco='git checkout'
    # allow to know which commits have been merged upstream/to specific branch
    alias gch='git cherry -v'
    alias gcp='git cherry-pick'
    alias gsl='git shortlog --email'

    # git for branch : execute command on a branch
    # parameters
    # 1 : branch name
    # 2 and more : command parameters (passed as-is)
    gfb () {
       local head="$(_current_branch)"
       [[ -n "$(git status -s)" ]] && echo "can't work on dirty state repo" && return 1
       local branch="${1:-master}"
       shift
       git checkout "$branch" 2>/dev/null 1>/dev/null
       echo "$branch -> $@\n"
       $@
       git checkout "$head" 2>/dev/null 1>/dev/null
    }

fi

which vim > /dev/null
if [[ 0 -eq $? ]]; then
    if [[ 1 -eq $IS_WINDOWS ]]; then
        alias v='gvim'
    else
        alias v='vim'
        alias gv='UBUNTU_MENUPROXY=gvim;gvim'
    fi
fi

# Virtualbox
which vboxmanage > /dev/null
if [[ 0 -eq $? ]]; then
    #TODO : add zsh autocompletion support

    _waitCommandEnd() {
       vboxmanage  showvminfo  "$1" >/dev/null
    }

    _powerOff(){
       vboxmanage controlvm "$1" poweroff
       _waitCommandEnd "$1"
    }

    _restoreCurrent(){
       vboxmanage snapshot "$1" restorecurrent
       _waitCommandEnd "$1"
    }

    _startVm(){
       vboxmanage startvm "$1"
       _waitCommandEnd "$1"
    }

    vbox(){
        cmd="${1:-list}"
        vmId="$2"
        targetFile="$3"

        case "$cmd" in
           "usage" )
              echo "usage :"
              echo "  vbox usage : display this help"
              echo "  vbox list : list VMs (and get their ID)"
              echo "  vbox playagain <id> : power off, restore snapshot and start vm"
              echo "  vbox start <id> : start vm"
              echo "  vbox stop <id> : stop vm (power off)"
              echo "  vbox export <id> [target] : export vm, defaults to box.ovf"
              return 1
              ;;
           "list" )
              vboxmanage list vms | sed 's/ {/ |{/' | column -t -s \|
              ;;
           "start" )
              _startVm "$vmId"
              ;;
           "playagain" )
              _powerOff "$vmId"
              _restoreCurrent "$vmId"
              _startVm "$vmId"
              ;;
           "stop" )
              _powerOff "$vmId"
              ;;
           "export" )
              vboxmanage export "$vimId" --output "${targetFile:-box.ovf}"
              ;;
        esac
        return $?
    }

fi
