#!/bin/bash

# "do" : execute one command on multiple folders
alias d='~/bin/d'

uname="$(uname)"
if [ 'MINGW' = "${uname:0:5}" ]; then
    IS_WINDOWS=1
else
    IS_WINDOWS=0
fi

if [[ 1 -eq $IS_WINDOWS ]]; then
    alias dir='ls'
fi

which xmlstarlet > /dev/null
if [[ 0 -eq $? ]]; then
    alias x='xmlstarlet'
fi


if [[ 1 -eq $IS_WINDOWS ]]; then
   o (){
      start "$@"
   }
else
    which xdg-open > /dev/null
    if [[ 0 -eq $? ]]; then
       o (){
           xdg-open "$@" 2> /dev/null
       }
   fi
fi

# Ack
# quick and dirty way to handle 'ack-grep' as 'ack'
which ack-grep > /dev/null
if [[ 0 -eq $? ]]; then
    alias ack='ack-grep'
fi
which ack > /dev/null
if [[ 0 -eq $? ]]; then
    alias a='ack'
    alias ai='ack -i'
    alias al='ack -l'
    alias ali='ack -li'
fi

# Cassandra cqlsh
which ack > /dev/null
if [[ 0 -eq $? ]]; then
    cqldesc(){
        cqlsh << END
describe keyspace $1
END
    }
fi


# Maven
which mvn > /dev/null
if [[ 0 -eq $? ]]; then
    # TODO : print error when cwd does not contains a pom.xml
    alias m='mvn'
    alias md='mvnDebug'
    alias mi='mvn install'
    alias mci='mvn clean install'
    alias mist='mvn install -DskipTests'
    alias mcist='mvn clean install -DskipTests'

    # default effective pom output
    mvn_effective_pom_file='target/effective-pom.xml'

    # maven effective pom
    mvn_effective_pom () {
       local out="${1:-$mvn_effective_pom_file}"
       mvn help:effective-pom -Doutput="$out" >/dev/null || return 1
    }

    # maven dependency graph (without clutter)
    mdep (){
       local outFile='target/.mdep'
       mvn dependency:tree -DoutputFile="$outFile" "$@">/dev/null
       if [[ 0 -eq $? ]]; then
          cat **/$outFile
          /bin/rm -f **/$outFile
       else
          echo "error : can't retrieve dependency tree, 'clean install' required if you haven't built project yet"
       fi
    }

    # maven project version (with submodules)
    which xmlstarlet > /dev/null
    if [[ 0 -ne $? ]]; then
        mpv () {
            echo "missing dependency : xmlstarlet"
            return 1;
        }
    else
        mpv () {
           mvn_effective_pom || return 1

           # remove namespace declarations for easy selection (xmlstarlet is a pain here)
           sed -i 's/<project .*>/<project>/' "${mvn_effective_pom_file}"

           xmlstarlet sel -t -m '//project' \
              -v 'groupId'  -o ' '  -v 'artifactId'  -o ' '  -v 'version' -n \
              "${mvn_effective_pom_file}"
           /bin/rm -f "${mvn_effective_pom_file}"
        }
    fi


    # maven effective pom (output to console for easy grep)
    mep () {
       local out="${1:-$mvn_effective_pom_file}"
       mvn_effective_pom $out && cat $out && /bin/rm -f $out
    }


fi

# Git
which git > /dev/null
if [[ 0 -eq $? ]]; then
    # taken as-is form zsh/oh-my-zsh configuration to make it work with bash too
    _current_branch () {
      ref=$(git symbolic-ref HEAD 2>/dev/null) || head=$(git rev-parse --short HEAD 2>/dev/null)
      echo ${ref#refs/heads/}
    }

    alias g='git'
    alias gl='git log --decorate --oneline --graph'
    alias gla='git log --decorate --oneline --graph --all'
    alias gld='git log --decorate --oneline --graph --simplify-by-decoration'
    alias gls='git ls-files --exclude-standard'
    alias gh='git help'
    alias gpr='git pull --rebase'
    alias gp='git pull'
    alias gpu='git push'
    alias gf='git fetch --all --tags'
    alias gst='git status -sb'
    alias ga='git add'
    alias gap='git add -vp'
    alias gai='git add -i'
    alias gr='git reset'
    alias gds='git diff --staged'
    alias gd='git diff'
    alias gc='git commit'
    alias ggpull='git pull --rebase origin $(_current_branch) && git fetch origin $(_current_branch)'
    alias ggpush='git push origin $(_current_branch)'
    # TODO : improve 'gco' to make it set upstream branch when checkout origin/branch
    # -> only when branch name starts with 'origin/' because we (very rarely) need to 
    # checkout a remote branch
    alias gco='git checkout'
    # allow to know which commits have been merged upstream/to specific branch
    alias gch='git cherry -v'
    alias gcp='git cherry-pick'
    alias gsl='git shortlog --email'

    alias gdesc='git describe --tags --always --dirty'

    # git commit files : modified files in ref
    alias gcf='git diff-tree --no-commit-id --name-only -r "$@"'

    # edit modified files with $EDITOR
    alias vgm='$EDITOR $(gls -m)'

    # git list unmerged files
    glsu (){
       git ls-files -u | awk '{print $4}' | sort -u
    }

    # git for branch : execute command on a branch
    # parameters
    # 1 : branch name
    # 2 and more : command parameters (passed as-is)
    gfb () {
       local head="$(_current_branch)"
       [[ -n "$(git status -s)" ]] && echo "can't work on dirty state repo" && return 1
       local branch="${1:-master}"
       shift
       git checkout "$branch" 2>/dev/null 1>/dev/null
       echo "$branch -> $@\n"
       $@
       git checkout "$head" 2>/dev/null 1>/dev/null
    }

    # git repo url
    gru (){
      echo "$(git config --get remote.origin.url | sed -e 's+git@\(.*\):\(.*\)\.git+https://\1/\2/+')"
    }
    # git branch url
    # parameters :
    # 1 : branch name, defaults to current branch if not provided
    gbu (){
      local branch="${1:-$(_current_branch)}"
      echo "$(gru)tree/$branch"
    }
    # git commit url
    # generate commit url using repository url, tested only with github
    # parameters :
    # 1 : commit ref, fallback to HEAD if not provided
    gcu (){
      local ref="$(git rev-parse ${1:-HEAD})"
      echo "$(gru)commit/$ref"
    }
    if [ -n "$JIRA_URL" ]; then
      # generate git jira message
      # parameters :
      # 1 : commit ref (defaults to HEAD)
      # 2 : branch name (defaults to current branch)
      gjm (){
         local commit="$(git rev-parse ${1:-HEAD})"
         local commitUrl="$(gcu $commit)"
         local branch="${2:-$(_current_branch)}"
         local branchUrl="$(gbu $branch)"
         echo "fixed at commit [[$commit|$commitUrl]]"
         echo "on branch [[$branch|$branchUrl]]"
      }
   fi

fi


which vim > /dev/null
if [[ 0 -eq $? ]]; then
    if [[ 1 -eq $IS_WINDOWS ]]; then
        alias v='gvim'
    else
        alias v='vim'
        alias gv='UBUNTU_MENUPROXY=gvim;gvim'
    fi
fi

# Virtualbox
which vboxmanage > /dev/null
if [[ 0 -eq $? ]]; then
    #TODO : add zsh autocompletion support

    _waitCommandEnd() {
       vboxmanage  showvminfo  "$1" >/dev/null
    }

    _powerOff(){
       vboxmanage controlvm "$1" poweroff
       _waitCommandEnd "$1"
    }

    _restoreCurrent(){
       vboxmanage snapshot "$1" restorecurrent
       _waitCommandEnd "$1"
    }

    _startVm(){
       vboxmanage startvm "$1"
       _waitCommandEnd "$1"
    }

    vbox(){
        cmd="${1:-list}"
        vmId="$2"
        targetFile="$3"

        case "$cmd" in
           "usage" )
              echo "usage :"
              echo "  vbox usage : display this help"
              echo "  vbox list : list VMs (and get their ID)"
              echo "  vbox playagain <id> : power off, restore snapshot and start vm"
              echo "  vbox start <id> : start vm"
              echo "  vbox stop <id> : stop vm (power off)"
              echo "  vbox export <id> [target] : export vm, defaults to box.ovf"
              return 1
              ;;
           "list" )
              vboxmanage list vms | sed 's/ {/ |{/' | column -t -s \|
              ;;
           "start" )
              _startVm "$vmId"
              ;;
           "playagain" )
              _powerOff "$vmId"
              _restoreCurrent "$vmId"
              _startVm "$vmId"
              ;;
           "stop" )
              _powerOff "$vmId"
              ;;
           "export" )
              vboxmanage export "$vimId" --output "${targetFile:-box.ovf}"
              ;;
        esac
        return $?
    }

fi

# easy filesytem nav
# thanks to http://jeroenjanssens.com/2013/08/16/quickly-navigate-your-filesystem-from-the-command-line.html
# TODO : bypass calls to "column" when it does not exists (like on windows)
export MARKPATH=$HOME/.marks
jump() {
    cd -P "$MARKPATH/$1" 2>/dev/null || echo "No such mark: $1"
}
alias j='jump'
mark() {
    mkdir -p "$MARKPATH"; ln -s "$(pwd)" "$MARKPATH/$1"
}
unmark() {
    /bin/rm -i "$MARKPATH/$1"
}
marks() {
    ls -l "$MARKPATH" | sed 's/\s\+/ /g' | cut -d' ' -f9- | sed 's/ -/\t-/g' | column -t
}
if [[ 'zsh' = "${SHELL#/bin/}" ]];then
   # zsh style completion
   _completemarks() {
       reply=($(ls $MARKPATH))
   }
   compctl -K _completemarks jump
   compctl -K _completemarks unmark
fi

if [[ 'bash' = "${SHELL#/bin/}" ]];then
   # bash style completion
   _completemarks() {
     local curw=${COMP_WORDS[COMP_CWORD]}
     local wordlist=$(find $MARKPATH -type l -printf "%f\n")
     COMPREPLY=($(compgen -W '${wordlist[@]}' -- "$curw"))
     return 0
   }
   complete -F _completemarks jump unmark
fi

# ssh "audit" : see who accesses what
sshaudit (){
   for server in "$@"; do
      # note : we use grep to prefix each line with file name
      ssh $server -C 'sudo grep -H "^" $(sudo find /root/.ssh/ -name authorized_keys) $(sudo ls -0d /home/*/.ssh/authorized_keys)' | sort | while read line; do
         tmp="$(mktemp)"
         echo "$line" | sed 's/^.*://' > "$tmp" # remove file prefix
         # get user from file location
         [[ $line == /root/* ]] \
            && user=root \
            || user=$(echo "$line" | sed 's+/home/\(.*\)/\.ssh.*$+\1+')
         echo $server $user $(ssh-keygen -lf "$tmp")
         /bin/rm -f "$tmp"
      done
   done
}


#TODO : make script to find war by itself (or take the 1st), so that only deployment name is required

if [[ -f "${TOMCAT_HOME}/bin/catalina.sh" ]]; then

	tomcat_cleanlog (){
		/bin/rm -rf $TOMCAT_HOME/logs/*
	}

	tomcat_log (){
		tail -F $TOMCAT_HOME/logs/*
	}

	tomcat_start (){
		${TOMCAT_HOME}/bin/catalina.sh start
	}

	tomcat_stop (){
		${TOMCAT_HOME}/bin/catalina.sh stop -force $1
	}

	tomcat_deploy (){
		war=${1?ERROR usage : tomcat_deploy <your-app.war>}
		fullPath="$(pwd)/$1"
		filename="${1##*/}" 
		name="${2:-${filename%.war}}"
		echo "deploy $fullPath as $name"
		
		rm -rf ${TOMCAT_HOME}/webapps/${name}{,.war}
		cp $fullPath ${TOMCAT_HOME}/webapps/${name}.war
		
	}

	tomcat (){
		case "$1" in
			log)
				tomcat_log &
				;;
			conf)
				$EDITOR ${TOMCAT_HOME}/bin/setenv.sh
				;;
			viewlog)
				$EDITOR ${TOMCAT_HOME}/logs/catalina.out
				;;
			start)
				tomcat_cleanlog
				tomcat_start
				;;
			stop)
				tomcat_stop
				;;
			restart)
				tomcat_stop
				tomcat_cleanlog
				tomcat_start
				;;
			deploy)
				tomcat_stop
				tomcat_cleanlog
				tomcat_deploy $2 $3
				tomcat_start
				;;
			clean)
				tomcat_stop
				tomcat_cleanlog
				rm -rf ${TOMCAT_HOME}/work && mkdir ${TOMCAT_HOME}/work
				rm -rf ${TOMCAT_HOME}/webapps && mkdir ${TOMCAT_HOME}/webapps
			;;
			*)
				echo "usage : $0 [start|stop|conf|restart|log|viewlog|deploy|]"
				;;
		esac
	}

	alias t='tomcat'
	alias tl='tomcat log'
	alias tvl='tomcat viewlog'
	alias ts='tomcat stop'
	alias trs='tomcat restart'
	# TODO : provide zsh|bash completion for tomcat command
fi

which javap > /dev/null
if [[ 0 -eq $? ]]; then
	# from .class file
	jp(){
		javap -c -verbose $1
	}
	vjp(){
		vim =(jp $1)
	}

	# from .class within a .jar
	jjp(){
		jarFile=${1}
		classFile=${2}

		tmpFile="/tmp/$(basename ${classFile})"
		unzip -p ${jarFile} ${classFile} > ${tmpFile}
		jp ${tmpFile}
		rm ${tmpFile}
	}
	vjjp(){
		vim =(jjp $1 $2)
	}


	vdjp(){
		vimdiff =(jp $1) =(jp $2)
	}
fi

if [[ -e "${NUDGE_PROBE_HOME}" ]]; then
	# nudge probe commands	

	nudge_probe(){
		cmd="$1"
		[[ $# > 0 ]] && shift
		case "${cmd}" in
			log)
				tail -F ${NUDGE_PROBE_HOME}/log/nudge.log
			;;
			instrumented)
				cat ${NUDGE_PROBE_HOME}/log/nudge.log | grep 'instrumentation'
			;;
			logview)
				${EDITOR:-vi} ${NUDGE_PROBE_HOME}/log/nudge.log
			;;
			clean)
				/bin/rm -rf ${NUDGE_PROBE_HOME}/log/*
			;;
			conf)
				${EDITOR:-vim} ${NUDGE_PROBE_HOME}/nudge.properties
			;;
			view)
				[[ $# > 0 ]] \
					&& java -jar ${NUDGE_PROBE_HOME}/nudge-*.jar -va "$@" \
					|| java -jar ${NUDGE_PROBE_HOME}/nudge-*.jar -va ${NUDGE_PROBE_HOME}/log/raw*.log
			;;
			print)
				java -jar ${NUDGE_PROBE_HOME}/nudge-*.jar -pa "$@"
			;;
			*)
				echo "usage : $0 [log|logview|clean|conf|view|print]"
				;;
		esac
	}

	np(){
		nudge_probe "$@"
	}

	alias npl='nudge_probe log'
	alias npi='nudge_probe instrumented'
	alias npvl='nudge_probe logview'
	alias npc='nudge_probe clean'
	alias npp='nudge_probe print'
	alias npd='nudge_probe view'
fi

if [[ -f "${VISUAL_VM_HOME}/bin/visualvm" ]];then

	visualvm(){
		rm -f ~/.visualvm/*/lock 2>&1 > /dev/null
		export JAVA_HOME=/usr/lib/jvm/java8oracle
		${VISUAL_VM_HOME}/bin/visualvm --jdkhome $JAVA_HOME&
	}
fi


if [[ -f "/usr/bin/teamviewer" ]]; then
	launch_teamviewer(){
		sudo systemctl start teamviewerd.service
		/usr/bin/teamviewer
		sudo systemctl stop teamviewerd.service
	}
	alias teamviewer='launch_teamviewer &'
fi


which vagrant > /dev/null
if [[ 0 -eq $? ]]; then
	vagu(){
		vagrant up
	}
	vagd(){
		vagrant destroy --force
	}
	vagdu(){
		vagd
		vagu
	}
fi
